diff --git a/lib/tsc.js b/lib/tsc.js
index bc3daf13f..51f502c7b 100644
--- a/lib/tsc.js
+++ b/lib/tsc.js
@@ -5028,6 +5028,9 @@ var sys = (() => {
       }
     }
     function isFileSystemCaseSensitive() {
+      if (typeof process.versions.pnp !== `undefined`) {
+        return true;
+      }
       if (platform === "win32" || platform === "win64") {
         return false;
       }
@@ -18688,12 +18691,6 @@ function getPropertyNameFromType(type) {
 function isExpandoPropertyDeclaration(declaration) {
   return !!declaration && (isPropertyAccessExpression(declaration) || isElementAccessExpression(declaration) || isBinaryExpression(declaration));
 }
-function hasResolutionModeOverride(node) {
-  if (node === void 0) {
-    return false;
-  }
-  return !!getResolutionModeOverride(node.attributes);
-}
 var stringReplace = String.prototype.replace;
 function replaceFirstStar(s, replacement) {
   return stringReplace.call(s, "*", replacement);
@@ -38477,6 +38474,48 @@ function getDefaultValueForOption(option) {
   }
 }

+// src/compiler/pnpapi.ts
+var { findPnpApi } = require("module");
+function getPnpApi(path) {
+  if (typeof process.versions.pnp === "undefined") {
+    return;
+  }
+  if (findPnpApi) {
+    return findPnpApi(`${path}/`);
+  }
+}
+function getPnpApiPath(path) {
+  var _a;
+  return (_a = getPnpApi(path)) == null ? void 0 : _a.resolveRequest(
+    "pnpapi",
+    /*issuer*/
+    null
+  );
+}
+
+// src/compiler/pnp.ts
+function getPnpTypeRoots(currentDirectory) {
+  const pnpApi = getPnpApi(currentDirectory);
+  if (!pnpApi) {
+    return [];
+  }
+  currentDirectory = resolvePath(currentDirectory);
+  const currentPackage = pnpApi.findPackageLocator(`${currentDirectory}/`);
+  if (!currentPackage) {
+    return [];
+  }
+  const { packageDependencies } = pnpApi.getPackageInformation(currentPackage);
+  const typeRoots = [];
+  for (const [name, referencish] of Array.from(packageDependencies.entries())) {
+    if (name.startsWith(`@types/`) && referencish !== null) {
+      const dependencyLocator = pnpApi.getLocator(name, referencish);
+      const { packageLocation } = pnpApi.getPackageInformation(dependencyLocator);
+      typeRoots.push(getDirectoryPath(packageLocation));
+    }
+  }
+  return typeRoots;
+}
+
 // src/compiler/moduleNameResolver.ts
 function trace(host, message, ...args) {
   host.trace(formatMessage(message, ...args));
@@ -38694,7 +38733,7 @@ function getEffectiveTypeRoots(options, host) {
     return getDefaultTypeRoots(currentDirectory);
   }
 }
-function getDefaultTypeRoots(currentDirectory) {
+function getNodeModulesTypeRoots(currentDirectory) {
   let typeRoots;
   forEachAncestorDirectory(normalizePath(currentDirectory), (directory) => {
     const atTypes = combinePaths(directory, nodeModulesAtTypes);
@@ -38707,6 +38746,15 @@ function arePathsEqual(path1, path2, host) {
   const useCaseSensitiveFileNames2 = typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames() : host.useCaseSensitiveFileNames;
   return comparePaths(path1, path2, !useCaseSensitiveFileNames2) === 0 /* EqualTo */;
 }
+function getDefaultTypeRoots(currentDirectory) {
+  const nmTypes = getNodeModulesTypeRoots(currentDirectory);
+  const pnpTypes = getPnpTypeRoots(currentDirectory);
+  if (nmTypes == null ? void 0 : nmTypes.length) {
+    return [...nmTypes, ...pnpTypes];
+  } else if (pnpTypes.length) {
+    return pnpTypes;
+  }
+}
 function getOriginalAndResolvedFileName(fileName, host, traceEnabled) {
   const resolvedFileName = realPath(fileName, host, traceEnabled);
   const pathsAreEqual = arePathsEqual(fileName, resolvedFileName, host);
@@ -40595,7 +40643,15 @@ function loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName,
     return lookup(secondaryExtensions);
   }
   function lookup(extensions2) {
-    return forEachAncestorDirectory(normalizeSlashes(directory), (ancestorDirectory) => {
+    const issuer = normalizeSlashes(directory);
+    if (getPnpApi(issuer)) {
+      const resolutionFromCache = tryFindNonRelativeModuleNameInCache(cache, moduleName, mode, issuer, redirectedReference, state);
+      if (resolutionFromCache) {
+        return resolutionFromCache;
+      }
+      return toSearchResult(loadModuleFromImmediateNodeModulesDirectoryPnP(extensions2, moduleName, issuer, state, typesScopeOnly, cache, redirectedReference));
+    }
+    return forEachAncestorDirectory(issuer, (ancestorDirectory) => {
       if (getBaseFileName(ancestorDirectory) !== "node_modules") {
         const resolutionFromCache = tryFindNonRelativeModuleNameInCache(cache, moduleName, mode, ancestorDirectory, redirectedReference, state);
         if (resolutionFromCache) {
@@ -40630,11 +40686,40 @@ function loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, dir
     return loadModuleFromSpecificNodeModulesDirectory(4 /* Declaration */, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes2, nodeModulesAtTypesExists, state, cache, redirectedReference);
   }
 }
+function loadModuleFromImmediateNodeModulesDirectoryPnP(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
+  const issuer = normalizeSlashes(directory);
+  if (!typesScopeOnly) {
+    const packageResult = tryLoadModuleUsingPnpResolution(extensions, moduleName, issuer, state, cache, redirectedReference);
+    if (packageResult) {
+      return packageResult;
+    }
+  }
+  if (extensions & 4 /* Declaration */) {
+    return tryLoadModuleUsingPnpResolution(4 /* Declaration */, `@types/${mangleScopedPackageNameWithTrace(moduleName, state)}`, issuer, state, cache, redirectedReference);
+  }
+}
 function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
-  var _a, _b;
   const candidate = normalizePath(combinePaths(nodeModulesDirectory, moduleName));
   const { packageName, rest } = parsePackageName(moduleName);
   const packageDirectory = combinePaths(nodeModulesDirectory, packageName);
+  return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory);
+}
+function loadModuleFromPnpResolution(extensions, packageDirectory, rest, state, cache, redirectedReference) {
+  const candidate = normalizePath(combinePaths(packageDirectory, rest));
+  return loadModuleFromSpecificNodeModulesDirectoryImpl(
+    extensions,
+    /*nodeModulesDirectoryExists*/
+    true,
+    state,
+    cache,
+    redirectedReference,
+    candidate,
+    rest,
+    packageDirectory
+  );
+}
+function loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory) {
+  var _a, _b;
   let rootPackageInfo;
   let packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
   if (rest !== "" && packageInfo && (!(state.features & 8 /* Exports */) || !hasProperty(((_a = rootPackageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state)) == null ? void 0 : _a.contents.packageJsonContent) ?? emptyArray, "exports"))) {
@@ -40935,6 +41020,26 @@ function traceIfEnabled(state, diagnostic, ...args) {
 function useCaseSensitiveFileNames(state) {
   return !state.host.useCaseSensitiveFileNames ? true : typeof state.host.useCaseSensitiveFileNames === "boolean" ? state.host.useCaseSensitiveFileNames : state.host.useCaseSensitiveFileNames();
 }
+var { isBuiltin } = require("module");
+var failedLookups = /* @__PURE__ */ new Set();
+function loadPnpPackageResolution(packageName, containingDirectory) {
+  if (failedLookups.has(packageName)) {
+    return;
+  }
+  try {
+    const resolution = getPnpApi(containingDirectory).resolveToUnqualified(packageName, `${containingDirectory}/`, { considerBuiltins: false });
+    return normalizeSlashes(resolution).replace(/\/$/, "");
+  } catch {
+    if (isBuiltin(packageName) || packageName.startsWith("@types/") && isBuiltin(packageName.slice(7)) || (packageName.startsWith("@typescript/") || packageName.startsWith("@types/typescript__"))) {
+      failedLookups.add(packageName);
+    }
+  }
+}
+function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference) {
+  const { packageName, rest } = parsePackageName(moduleName);
+  const packageResolution = loadPnpPackageResolution(packageName, containingDirectory);
+  return packageResolution ? loadModuleFromPnpResolution(extensions, packageResolution, rest, state, cache, redirectedReference) : void 0;
+}

 // src/compiler/binder.ts
 function getModuleInstanceState(node, visited) {
@@ -44359,7 +44464,15 @@ function getAllModulePathsWorker(info, importedFileName, host, compilerOptions,
     /*preferSymlinks*/
     true,
     (path, isRedirect) => {
-      const isInNodeModules = pathContainsNodeModules(path);
+      let isInNodeModules = pathContainsNodeModules(path);
+      const pnpapi = getPnpApi(path);
+      if (!isInNodeModules && pnpapi) {
+        const fromLocator = pnpapi.findPackageLocator(info.importingSourceFileName);
+        const toLocator = pnpapi.findPackageLocator(path);
+        if (fromLocator && toLocator && fromLocator !== toLocator) {
+          isInNodeModules = true;
+        }
+      }
       allFileNames.set(path, { path: info.getCanonicalFileName(path), isRedirect, isInNodeModules });
       importedFileFromNodeModules = importedFileFromNodeModules || isInNodeModules;
     }
@@ -44650,7 +44763,41 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
   if (!host.fileExists || !host.readFile) {
     return void 0;
   }
-  const parts = getNodeModulePathParts(path);
+  let parts = getNodeModulePathParts(path);
+  let pnpPackageName;
+  const pnpApi = getPnpApi(path);
+  if (pnpApi) {
+    const fromLocator = pnpApi.findPackageLocator(importingSourceFile.fileName);
+    const toLocator = pnpApi.findPackageLocator(path);
+    if (fromLocator === toLocator) {
+      return void 0;
+    }
+    if (fromLocator && toLocator) {
+      const fromInfo = pnpApi.getPackageInformation(fromLocator);
+      if (toLocator.reference === fromInfo.packageDependencies.get(toLocator.name)) {
+        pnpPackageName = toLocator.name;
+      } else {
+        for (const [name, reference] of fromInfo.packageDependencies) {
+          if (Array.isArray(reference)) {
+            if (reference[0] === toLocator.name && reference[1] === toLocator.reference) {
+              pnpPackageName = name;
+              break;
+            }
+          }
+        }
+      }
+      if (!parts) {
+        const toInfo = pnpApi.getPackageInformation(toLocator);
+        parts = {
+          topLevelNodeModulesIndex: void 0,
+          topLevelPackageNameIndex: void 0,
+          // The last character from packageLocation is the trailing "/", we want to point to it
+          packageRootIndex: toInfo.packageLocation.length - 1,
+          fileNameIndex: path.lastIndexOf(`/`)
+        };
+      }
+    }
+  }
   if (!parts) {
     return void 0;
   }
@@ -44687,14 +44834,16 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
   if (isRedirect && !isPackageRootPath) {
     return void 0;
   }
-  const globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
-  const pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
-  if (!(startsWith(canonicalSourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
-    return void 0;
+  if (typeof process.versions.pnp === "undefined") {
+    const globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
+    const pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
+    if (!(startsWith(canonicalSourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
+      return void 0;
+    }
   }
-  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
-  const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
-  return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
+  const nodeModulesDirectoryName = typeof pnpPackageName !== "undefined" ? pnpPackageName + moduleSpecifier.substring(parts.packageRootIndex) : moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+  const packageNameFromPath = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
+  return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageNameFromPath === nodeModulesDirectoryName ? void 0 : packageNameFromPath;
   function tryDirectoryWithPackageJson(packageRootIndex) {
     var _a, _b;
     const packageRootPath = path.substring(0, packageRootIndex);
@@ -44707,9 +44856,9 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
       const importMode = overrideMode || getDefaultResolutionModeForFile(importingSourceFile, host, options);
       if (getResolvePackageJsonExports(options)) {
         const nodeModulesDirectoryName2 = packageRootPath.substring(parts.topLevelPackageNameIndex + 1);
-        const packageName2 = getPackageNameFromTypesPackageName(nodeModulesDirectoryName2);
+        const packageName = getPackageNameFromTypesPackageName(pnpPackageName ? pnpPackageName : nodeModulesDirectoryName2);
         const conditions = getConditions(options, importMode);
-        const fromExports = (packageJsonContent == null ? void 0 : packageJsonContent.exports) ? tryGetModuleNameFromExports(options, host, path, packageRootPath, packageName2, packageJsonContent.exports, conditions) : void 0;
+        const fromExports = (packageJsonContent == null ? void 0 : packageJsonContent.exports) ? tryGetModuleNameFromExports(options, host, path, packageRootPath, packageName, packageJsonContent.exports, conditions) : void 0;
         if (fromExports) {
           return { ...fromExports, verbatimFromExports: true };
         }
@@ -45348,6 +45497,8 @@ function createTypeChecker(host) {
     getApparentType,
     getUnionType,
     isTypeAssignableTo,
+    isTypeIdenticalTo,
+    isTypeSubtypeOf,
     createAnonymousType,
     createSignature,
     createSymbol,
@@ -47126,7 +47277,7 @@ function createTypeChecker(host) {
     }
   }
   function getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias) {
-    var _a;
+    var _a, _b;
     let exportDefaultSymbol;
     if (isShorthandAmbientModuleSymbol(moduleSymbol)) {
       exportDefaultSymbol = moduleSymbol;
@@ -47135,7 +47286,7 @@ function createTypeChecker(host) {
     }
     const file = (_a = moduleSymbol.declarations) == null ? void 0 : _a.find(isSourceFile);
     const specifier = getModuleSpecifierForImportOrExport(node);
-    if (!specifier) {
+    if (!specifier || moduleSymbol.flags === 512 && ((_b = moduleSymbol.exports) == null ? void 0 : _b.has("default"))) {
       return exportDefaultSymbol;
     }
     const hasDefaultOnly = isOnlyImportableAsDefault(specifier);
@@ -47964,7 +48115,7 @@ function createTypeChecker(host) {
             moduleReference
           );
         }
-        if (moduleResolutionKind === 3 /* Node16 */ || moduleResolutionKind === 99 /* NodeNext */) {
+        if (false) {
           const isSyncImport = currentSourceFile.impliedNodeFormat === 1 /* CommonJS */ && !findAncestor(location, isImportCall) || !!findAncestor(location, isImportEqualsDeclaration);
           const overrideHost = findAncestor(location, (l) => isImportTypeNode(l) || isExportDeclaration(l) || isImportDeclaration(l));
           if (isSyncImport && sourceFile.impliedNodeFormat === 99 /* ESNext */ && !hasResolutionModeOverride(overrideHost)) {
@@ -47972,7 +48123,7 @@ function createTypeChecker(host) {
               error(errorNode, Diagnostics.Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead, moduleReference);
             } else {
               let diagnosticDetails;
-              const ext = tryGetExtensionFromPath2(currentSourceFile.fileName);
+              const ext = tryGetExtensionFromPath3(currentSourceFile.fileName);
               if (ext === ".ts" /* Ts */ || ext === ".js" /* Js */ || ext === ".tsx" /* Tsx */ || ext === ".jsx" /* Jsx */) {
                 const scope = currentSourceFile.packageJsonScope;
                 const targetExt = ext === ".ts" /* Ts */ ? ".mts" /* Mts */ : ext === ".js" /* Js */ ? ".mjs" /* Mjs */ : void 0;
@@ -47983,14 +48134,14 @@ function createTypeChecker(host) {
                       void 0,
                       Diagnostics.To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Colon_module_to_1,
                       targetExt,
-                      combinePaths(scope.packageDirectory, "package.json")
+                      combinePaths2(scope.packageDirectory, "package.json")
                     );
                   } else {
                     diagnosticDetails = chainDiagnosticMessages(
                       /*details*/
                       void 0,
                       Diagnostics.To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0,
-                      combinePaths(scope.packageDirectory, "package.json")
+                      combinePaths2(scope.packageDirectory, "package.json")
                     );
                   }
                 } else {
@@ -112334,10 +112485,7 @@ function getOutputExtension(fileName, options) {
   return fileExtensionIs(fileName, ".json" /* Json */) ? ".json" /* Json */ : options.jsx === 1 /* Preserve */ && fileExtensionIsOneOf(fileName, [".jsx" /* Jsx */, ".tsx" /* Tsx */]) ? ".jsx" /* Jsx */ : fileExtensionIsOneOf(fileName, [".mts" /* Mts */, ".mjs" /* Mjs */]) ? ".mjs" /* Mjs */ : fileExtensionIsOneOf(fileName, [".cts" /* Cts */, ".cjs" /* Cjs */]) ? ".cjs" /* Cjs */ : ".js" /* Js */;
 }
 function getOutputPathWithoutChangingExt(inputFileName, ignoreCase, outputDir, getCommonSourceDirectory2) {
-  return outputDir ? resolvePath(
-    outputDir,
-    getRelativePathFromDirectory(getCommonSourceDirectory2(), inputFileName, ignoreCase)
-  ) : inputFileName;
+  return outputDir ? `${outputDir}${directorySeparator}${inputFileName.slice(getCommonSourceDirectory2().length)}` : inputFileName;
 }
 function getOutputDeclarationFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory2 = () => getCommonSourceDirectoryOfConfig(configFile, ignoreCase)) {
   return getOutputDeclarationFileNameWorker(inputFileName, configFile.options, ignoreCase, getCommonSourceDirectory2);
@@ -125193,6 +125341,11 @@ function createWatchProgram(host) {
   if (configFileName) {
     configFileWatcher = watchFile2(configFileName, scheduleProgramReload, 2e3 /* High */, watchOptions, WatchType.ConfigFile);
   }
+  let pnpFileWatcher;
+  const pnpApiPath = getPnpApiPath(__filename);
+  if (pnpApiPath) {
+    pnpFileWatcher = watchFile2(pnpApiPath, scheduleResolutionReload, 2e3 /* High */, watchOptions, WatchType.ConfigFile);
+  }
   const compilerHost = createCompilerHostFromProgramHost(host, () => compilerOptions, directoryStructureHost);
   setGetSourceFileAsHashVersioned(compilerHost);
   const getNewSourceFile = compilerHost.getSourceFile;
@@ -125255,6 +125408,10 @@ function createWatchProgram(host) {
       configFileWatcher.close();
       configFileWatcher = void 0;
     }
+    if (pnpFileWatcher) {
+      pnpFileWatcher.close();
+      pnpFileWatcher = void 0;
+    }
     extendedConfigCache == null ? void 0 : extendedConfigCache.clear();
     extendedConfigCache = void 0;
     if (sharedExtendedConfigFileWatchers) {
@@ -125290,7 +125447,7 @@ function createWatchProgram(host) {
   function getCurrentProgram() {
     return builderProgram && builderProgram.getProgramOrUndefined();
   }
-  function synchronizeProgram() {
+  function synchronizeProgram(forceAllFilesAsInvalidated = false) {
     writeLog(`Synchronizing program`);
     Debug.assert(compilerOptions);
     Debug.assert(rootFileNames);
@@ -125302,7 +125459,7 @@ function createWatchProgram(host) {
         resolutionCache.onChangesAffectModuleResolution();
       }
     }
-    const { hasInvalidatedResolutions, hasInvalidatedLibResolutions } = resolutionCache.createHasInvalidatedResolutions(customHasInvalidatedResolutions, customHasInvalidLibResolutions);
+    const { hasInvalidatedResolutions, hasInvalidatedLibResolutions } = resolutionCache.createHasInvalidatedResolutions(forceAllFilesAsInvalidated ? returnTrue : customHasInvalidatedResolutions, customHasInvalidLibResolutions);
     const {
       originalReadFile,
       originalFileExists,
@@ -125510,13 +125667,19 @@ function createWatchProgram(host) {
     updateLevel = 2 /* Full */;
     scheduleProgramUpdate();
   }
+  function scheduleResolutionReload() {
+    writeLog("Clearing resolutions");
+    resolutionCache.clear();
+    updateLevel = 3 /* Resolutions */;
+    scheduleProgramUpdate();
+  }
   function updateProgramWithWatchStatus() {
     timerToUpdateProgram = void 0;
     reportFileChangeDetectedOnCreateProgram = true;
     updateProgram();
   }
   function updateProgram() {
-    var _a, _b, _c, _d;
+    var _a, _b, _c, _d, _e;
     switch (updateLevel) {
       case 1 /* RootNamesAndUpdate */:
         (_a = perfLogger) == null ? void 0 : _a.logStartUpdateProgram("PartialConfigReload");
@@ -125526,12 +125689,19 @@ function createWatchProgram(host) {
         (_b = perfLogger) == null ? void 0 : _b.logStartUpdateProgram("FullConfigReload");
         reloadConfigFile();
         break;
+      case 3 /* Resolutions */:
+        (_c = perfLogger) == null ? void 0 : _c.logStartUpdateProgram("SynchronizeProgramWithResolutions");
+        synchronizeProgram(
+          /*forceAllFilesAsInvalidated*/
+          true
+        );
+        break;
       default:
-        (_c = perfLogger) == null ? void 0 : _c.logStartUpdateProgram("SynchronizeProgram");
+        (_d = perfLogger) == null ? void 0 : _d.logStartUpdateProgram("SynchronizeProgram");
         synchronizeProgram();
         break;
     }
-    (_d = perfLogger) == null ? void 0 : _d.logStopUpdateProgram("Done");
+    (_e = perfLogger) == null ? void 0 : _e.logStopUpdateProgram("Done");
     return getCurrentBuilderProgram();
   }
   function reloadFileNamesFromConfigFile() {
diff --git a/lib/tsserver.js b/lib/tsserver.js
index 398a3a1ed..2be41fd2e 100644
--- a/lib/tsserver.js
+++ b/lib/tsserver.js
@@ -33,6 +33,25 @@ var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "defau
 var typescript_exports = {};
 __reExport(typescript_exports, require("./typescript.js"));

+// src/compiler/pnpapi.ts
+var { findPnpApi } = require("module");
+function getPnpApi(path) {
+  if (typeof process.versions.pnp === "undefined") {
+    return;
+  }
+  if (findPnpApi) {
+    return findPnpApi(`${path}/`);
+  }
+}
+function getPnpApiPath(path) {
+  var _a;
+  return (_a = getPnpApi(path)) == null ? void 0 : _a.resolveRequest(
+    "pnpapi",
+    /*issuer*/
+    null
+  );
+}
+
 // src/tsserver/common.ts
 function getLogLevel(level) {
   if (level) {
@@ -237,6 +256,10 @@ function initializeNodeSystem() {
         }
         try {
           const args = [(0, typescript_exports.combinePaths)(libDirectory, "watchGuard.js"), path];
+          const pnpApiPath = getPnpApiPath(__filename);
+          if (pnpApiPath) {
+            args.unshift("-r", pnpApiPath);
+          }
           if (logger.hasLevel(typescript_exports.server.LogLevel.verbose)) {
             logger.info(`Starting ${process.execPath} with args:${typescript_exports.server.stringifyIndented(args)}`);
           }
@@ -417,6 +440,10 @@ function startNodeSession(options, logger, cancellationToken) {
           break;
         }
       }
+      const pnpApiPath = getPnpApiPath(__filename);
+      if (pnpApiPath) {
+        execArgv.unshift("-r", pnpApiPath);
+      }
       const typingsInstaller = (0, typescript_exports.combinePaths)((0, typescript_exports.getDirectoryPath)(typescript_exports.sys.getExecutingFilePath()), "typingsInstaller.js");
       this.installer = childProcess.fork(typingsInstaller, args, { execArgv });
       this.installer.on("message", (m) => this.handleMessage(m));
diff --git a/lib/typescript.d.ts b/lib/typescript.d.ts
index 59692349a..c75e1031e 100644
--- a/lib/typescript.d.ts
+++ b/lib/typescript.d.ts
@@ -6242,6 +6242,8 @@ declare namespace ts {
          * ```
          */
         isTypeAssignableTo(source: Type, target: Type): boolean;
+        isTypeIdenticalTo(source: Type, target: Type): boolean;
+        isTypeSubtypeOf(source: Type, target: Type): boolean;
         /**
          * True if this type is the `Array` or `ReadonlyArray` type from lib.d.ts.
          * This function will _not_ return true if passed a type which
@@ -9370,6 +9372,8 @@ declare namespace ts {
          *  - Updating the program
          */
         Full = 2,
+        /** Reload the resolutions */
+        Resolutions = 3,
     }
     function findConfigFile(searchPath: string, fileExists: (fileName: string) => boolean, configName?: string): string | undefined;
     function resolveTripleslashReference(moduleName: string, containingFile: string): string;
diff --git a/lib/typescript.js b/lib/typescript.js
index 4528ee49e..7a69c7e05 100644
--- a/lib/typescript.js
+++ b/lib/typescript.js
@@ -8616,6 +8616,9 @@ var sys = (() => {
       }
     }
     function isFileSystemCaseSensitive() {
+      if (typeof process.versions.pnp !== `undefined`) {
+        return true;
+      }
       if (platform === "win32" || platform === "win64") {
         return false;
       }
@@ -42995,6 +42998,69 @@ function getDefaultValueForOption(option) {
   }
 }

+// src/compiler/pnpapi.ts
+var { findPnpApi } = require("module");
+function getPnpApi(path) {
+  if (typeof process.versions.pnp === "undefined") {
+    return;
+  }
+  if (findPnpApi) {
+    return findPnpApi(`${path}/`);
+  }
+}
+function getPnpApiPath(path) {
+  var _a;
+  return (_a = getPnpApi(path)) == null ? void 0 : _a.resolveRequest(
+    "pnpapi",
+    /*issuer*/
+    null
+  );
+}
+
+// src/compiler/pnp.ts
+function getPnpTypeRoots(currentDirectory) {
+  const pnpApi = getPnpApi(currentDirectory);
+  if (!pnpApi) {
+    return [];
+  }
+  currentDirectory = resolvePath(currentDirectory);
+  const currentPackage = pnpApi.findPackageLocator(`${currentDirectory}/`);
+  if (!currentPackage) {
+    return [];
+  }
+  const { packageDependencies } = pnpApi.getPackageInformation(currentPackage);
+  const typeRoots = [];
+  for (const [name, referencish] of Array.from(packageDependencies.entries())) {
+    if (name.startsWith(`@types/`) && referencish !== null) {
+      const dependencyLocator = pnpApi.getLocator(name, referencish);
+      const { packageLocation } = pnpApi.getPackageInformation(dependencyLocator);
+      typeRoots.push(getDirectoryPath(packageLocation));
+    }
+  }
+  return typeRoots;
+}
+function isImportablePathPnp(fromPath, toPath3) {
+  const pnpApi = getPnpApi(fromPath);
+  const fromLocator = pnpApi.findPackageLocator(fromPath);
+  const toLocator = pnpApi.findPackageLocator(toPath3);
+  if (toLocator === null) {
+    return false;
+  }
+  const fromInfo = pnpApi.getPackageInformation(fromLocator);
+  const toReference = fromInfo.packageDependencies.get(toLocator.name);
+  if (toReference) {
+    return toReference === toLocator.reference;
+  }
+  for (const reference of fromInfo.packageDependencies.values()) {
+    if (Array.isArray(reference)) {
+      if (reference[0] === toLocator.name && reference[1] === toLocator.reference) {
+        return true;
+      }
+    }
+  }
+  return false;
+}
+
 // src/compiler/moduleNameResolver.ts
 function trace(host, message, ...args) {
   host.trace(formatMessage(message, ...args));
@@ -43220,7 +43286,7 @@ function getEffectiveTypeRoots(options, host) {
     return getDefaultTypeRoots(currentDirectory);
   }
 }
-function getDefaultTypeRoots(currentDirectory) {
+function getNodeModulesTypeRoots(currentDirectory) {
   let typeRoots;
   forEachAncestorDirectory(normalizePath(currentDirectory), (directory) => {
     const atTypes = combinePaths(directory, nodeModulesAtTypes);
@@ -43233,6 +43299,15 @@ function arePathsEqual(path1, path2, host) {
   const useCaseSensitiveFileNames2 = typeof host.useCaseSensitiveFileNames === "function" ? host.useCaseSensitiveFileNames() : host.useCaseSensitiveFileNames;
   return comparePaths(path1, path2, !useCaseSensitiveFileNames2) === 0 /* EqualTo */;
 }
+function getDefaultTypeRoots(currentDirectory) {
+  const nmTypes = getNodeModulesTypeRoots(currentDirectory);
+  const pnpTypes = getPnpTypeRoots(currentDirectory);
+  if (nmTypes == null ? void 0 : nmTypes.length) {
+    return [...nmTypes, ...pnpTypes];
+  } else if (pnpTypes.length) {
+    return pnpTypes;
+  }
+}
 function getOriginalAndResolvedFileName(fileName, host, traceEnabled) {
   const resolvedFileName = realPath(fileName, host, traceEnabled);
   const pathsAreEqual = arePathsEqual(fileName, resolvedFileName, host);
@@ -43482,6 +43557,21 @@ function getConditions(options, resolutionMode) {
 }
 function resolvePackageNameToPackageJson(packageName, containingDirectory, options, host, cache) {
   const moduleResolutionState = getTemporaryModuleResolutionState(cache == null ? void 0 : cache.getPackageJsonInfoCache(), host, options);
+  const pnpapi = getPnpApi(containingDirectory);
+  if (pnpapi) {
+    try {
+      const resolution = pnpapi.resolveToUnqualified(packageName, `${containingDirectory}/`, { considerBuiltins: false });
+      const candidate = normalizeSlashes(resolution).replace(/\/$/, "");
+      return getPackageJsonInfo(
+        candidate,
+        /*onlyRecordFailures*/
+        false,
+        moduleResolutionState
+      );
+    } catch {
+      return;
+    }
+  }
   return forEachAncestorDirectory(containingDirectory, (ancestorDirectory) => {
     if (getBaseFileName(ancestorDirectory) !== "node_modules") {
       const nodeModulesFolder = combinePaths(ancestorDirectory, "node_modules");
@@ -45273,7 +45363,15 @@ function loadModuleFromNearestNodeModulesDirectoryWorker(extensions, moduleName,
     return lookup(secondaryExtensions);
   }
   function lookup(extensions2) {
-    return forEachAncestorDirectory(normalizeSlashes(directory), (ancestorDirectory) => {
+    const issuer = normalizeSlashes(directory);
+    if (getPnpApi(issuer)) {
+      const resolutionFromCache = tryFindNonRelativeModuleNameInCache(cache, moduleName, mode, issuer, redirectedReference, state);
+      if (resolutionFromCache) {
+        return resolutionFromCache;
+      }
+      return toSearchResult(loadModuleFromImmediateNodeModulesDirectoryPnP(extensions2, moduleName, issuer, state, typesScopeOnly, cache, redirectedReference));
+    }
+    return forEachAncestorDirectory(issuer, (ancestorDirectory) => {
       if (getBaseFileName(ancestorDirectory) !== "node_modules") {
         const resolutionFromCache = tryFindNonRelativeModuleNameInCache(cache, moduleName, mode, ancestorDirectory, redirectedReference, state);
         if (resolutionFromCache) {
@@ -45308,11 +45406,40 @@ function loadModuleFromImmediateNodeModulesDirectory(extensions, moduleName, dir
     return loadModuleFromSpecificNodeModulesDirectory(4 /* Declaration */, mangleScopedPackageNameWithTrace(moduleName, state), nodeModulesAtTypes2, nodeModulesAtTypesExists, state, cache, redirectedReference);
   }
 }
+function loadModuleFromImmediateNodeModulesDirectoryPnP(extensions, moduleName, directory, state, typesScopeOnly, cache, redirectedReference) {
+  const issuer = normalizeSlashes(directory);
+  if (!typesScopeOnly) {
+    const packageResult = tryLoadModuleUsingPnpResolution(extensions, moduleName, issuer, state, cache, redirectedReference);
+    if (packageResult) {
+      return packageResult;
+    }
+  }
+  if (extensions & 4 /* Declaration */) {
+    return tryLoadModuleUsingPnpResolution(4 /* Declaration */, `@types/${mangleScopedPackageNameWithTrace(moduleName, state)}`, issuer, state, cache, redirectedReference);
+  }
+}
 function loadModuleFromSpecificNodeModulesDirectory(extensions, moduleName, nodeModulesDirectory, nodeModulesDirectoryExists, state, cache, redirectedReference) {
-  var _a, _b;
   const candidate = normalizePath(combinePaths(nodeModulesDirectory, moduleName));
   const { packageName, rest } = parsePackageName(moduleName);
   const packageDirectory = combinePaths(nodeModulesDirectory, packageName);
+  return loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory);
+}
+function loadModuleFromPnpResolution(extensions, packageDirectory, rest, state, cache, redirectedReference) {
+  const candidate = normalizePath(combinePaths(packageDirectory, rest));
+  return loadModuleFromSpecificNodeModulesDirectoryImpl(
+    extensions,
+    /*nodeModulesDirectoryExists*/
+    true,
+    state,
+    cache,
+    redirectedReference,
+    candidate,
+    rest,
+    packageDirectory
+  );
+}
+function loadModuleFromSpecificNodeModulesDirectoryImpl(extensions, nodeModulesDirectoryExists, state, cache, redirectedReference, candidate, rest, packageDirectory) {
+  var _a, _b;
   let rootPackageInfo;
   let packageInfo = getPackageJsonInfo(candidate, !nodeModulesDirectoryExists, state);
   if (rest !== "" && packageInfo && (!(state.features & 8 /* Exports */) || !hasProperty(((_a = rootPackageInfo = getPackageJsonInfo(packageDirectory, !nodeModulesDirectoryExists, state)) == null ? void 0 : _a.contents.packageJsonContent) ?? emptyArray, "exports"))) {
@@ -45613,6 +45740,26 @@ function traceIfEnabled(state, diagnostic, ...args) {
 function useCaseSensitiveFileNames(state) {
   return !state.host.useCaseSensitiveFileNames ? true : typeof state.host.useCaseSensitiveFileNames === "boolean" ? state.host.useCaseSensitiveFileNames : state.host.useCaseSensitiveFileNames();
 }
+var { isBuiltin } = require("module");
+var failedLookups = /* @__PURE__ */ new Set();
+function loadPnpPackageResolution(packageName, containingDirectory) {
+  if (failedLookups.has(packageName)) {
+    return;
+  }
+  try {
+    const resolution = getPnpApi(containingDirectory).resolveToUnqualified(packageName, `${containingDirectory}/`, { considerBuiltins: false });
+    return normalizeSlashes(resolution).replace(/\/$/, "");
+  } catch {
+    if (isBuiltin(packageName) || packageName.startsWith("@types/") && isBuiltin(packageName.slice(7)) || (packageName.startsWith("@typescript/") || packageName.startsWith("@types/typescript__"))) {
+      failedLookups.add(packageName);
+    }
+  }
+}
+function tryLoadModuleUsingPnpResolution(extensions, moduleName, containingDirectory, state, cache, redirectedReference) {
+  const { packageName, rest } = parsePackageName(moduleName);
+  const packageResolution = loadPnpPackageResolution(packageName, containingDirectory);
+  return packageResolution ? loadModuleFromPnpResolution(extensions, packageResolution, rest, state, cache, redirectedReference) : void 0;
+}

 // src/compiler/binder.ts
 var ModuleInstanceState = /* @__PURE__ */ ((ModuleInstanceState2) => {
@@ -49154,7 +49301,15 @@ function getAllModulePathsWorker(info, importedFileName, host, compilerOptions,
     /*preferSymlinks*/
     true,
     (path, isRedirect) => {
-      const isInNodeModules = pathContainsNodeModules(path);
+      let isInNodeModules = pathContainsNodeModules(path);
+      const pnpapi = getPnpApi(path);
+      if (!isInNodeModules && pnpapi) {
+        const fromLocator = pnpapi.findPackageLocator(info.importingSourceFileName);
+        const toLocator = pnpapi.findPackageLocator(path);
+        if (fromLocator && toLocator && fromLocator !== toLocator) {
+          isInNodeModules = true;
+        }
+      }
       allFileNames.set(path, { path: info.getCanonicalFileName(path), isRedirect, isInNodeModules });
       importedFileFromNodeModules = importedFileFromNodeModules || isInNodeModules;
     }
@@ -49445,7 +49600,41 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
   if (!host.fileExists || !host.readFile) {
     return void 0;
   }
-  const parts = getNodeModulePathParts(path);
+  let parts = getNodeModulePathParts(path);
+  let pnpPackageName;
+  const pnpApi = getPnpApi(path);
+  if (pnpApi) {
+    const fromLocator = pnpApi.findPackageLocator(importingSourceFile.fileName);
+    const toLocator = pnpApi.findPackageLocator(path);
+    if (fromLocator === toLocator) {
+      return void 0;
+    }
+    if (fromLocator && toLocator) {
+      const fromInfo = pnpApi.getPackageInformation(fromLocator);
+      if (toLocator.reference === fromInfo.packageDependencies.get(toLocator.name)) {
+        pnpPackageName = toLocator.name;
+      } else {
+        for (const [name, reference] of fromInfo.packageDependencies) {
+          if (Array.isArray(reference)) {
+            if (reference[0] === toLocator.name && reference[1] === toLocator.reference) {
+              pnpPackageName = name;
+              break;
+            }
+          }
+        }
+      }
+      if (!parts) {
+        const toInfo = pnpApi.getPackageInformation(toLocator);
+        parts = {
+          topLevelNodeModulesIndex: void 0,
+          topLevelPackageNameIndex: void 0,
+          // The last character from packageLocation is the trailing "/", we want to point to it
+          packageRootIndex: toInfo.packageLocation.length - 1,
+          fileNameIndex: path.lastIndexOf(`/`)
+        };
+      }
+    }
+  }
   if (!parts) {
     return void 0;
   }
@@ -49482,14 +49671,16 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
   if (isRedirect && !isPackageRootPath) {
     return void 0;
   }
-  const globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
-  const pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
-  if (!(startsWith(canonicalSourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
-    return void 0;
+  if (typeof process.versions.pnp === "undefined") {
+    const globalTypingsCacheLocation = host.getGlobalTypingsCacheLocation && host.getGlobalTypingsCacheLocation();
+    const pathToTopLevelNodeModules = getCanonicalFileName(moduleSpecifier.substring(0, parts.topLevelNodeModulesIndex));
+    if (!(startsWith(canonicalSourceDirectory, pathToTopLevelNodeModules) || globalTypingsCacheLocation && startsWith(getCanonicalFileName(globalTypingsCacheLocation), pathToTopLevelNodeModules))) {
+      return void 0;
+    }
   }
-  const nodeModulesDirectoryName = moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
-  const packageName = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
-  return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageName === nodeModulesDirectoryName ? void 0 : packageName;
+  const nodeModulesDirectoryName = typeof pnpPackageName !== "undefined" ? pnpPackageName + moduleSpecifier.substring(parts.packageRootIndex) : moduleSpecifier.substring(parts.topLevelPackageNameIndex + 1);
+  const packageNameFromPath = getPackageNameFromTypesPackageName(nodeModulesDirectoryName);
+  return getEmitModuleResolutionKind(options) === 1 /* Classic */ && packageNameFromPath === nodeModulesDirectoryName ? void 0 : packageNameFromPath;
   function tryDirectoryWithPackageJson(packageRootIndex) {
     var _a, _b;
     const packageRootPath = path.substring(0, packageRootIndex);
@@ -49502,9 +49693,9 @@ function tryGetModuleNameAsNodeModule({ path, isRedirect }, { getCanonicalFileNa
       const importMode = overrideMode || getDefaultResolutionModeForFile(importingSourceFile, host, options);
       if (getResolvePackageJsonExports(options)) {
         const nodeModulesDirectoryName2 = packageRootPath.substring(parts.topLevelPackageNameIndex + 1);
-        const packageName2 = getPackageNameFromTypesPackageName(nodeModulesDirectoryName2);
+        const packageName = getPackageNameFromTypesPackageName(pnpPackageName ? pnpPackageName : nodeModulesDirectoryName2);
         const conditions = getConditions(options, importMode);
-        const fromExports = (packageJsonContent == null ? void 0 : packageJsonContent.exports) ? tryGetModuleNameFromExports(options, host, path, packageRootPath, packageName2, packageJsonContent.exports, conditions) : void 0;
+        const fromExports = (packageJsonContent == null ? void 0 : packageJsonContent.exports) ? tryGetModuleNameFromExports(options, host, path, packageRootPath, packageName, packageJsonContent.exports, conditions) : void 0;
         if (fromExports) {
           return { ...fromExports, verbatimFromExports: true };
         }
@@ -50143,6 +50334,8 @@ function createTypeChecker(host) {
     getApparentType,
     getUnionType,
     isTypeAssignableTo,
+    isTypeIdenticalTo,
+    isTypeSubtypeOf,
     createAnonymousType,
     createSignature,
     createSymbol,
@@ -51921,7 +52114,7 @@ function createTypeChecker(host) {
     }
   }
   function getTargetofModuleDefault(moduleSymbol, node, dontResolveAlias) {
-    var _a;
+    var _a, _b;
     let exportDefaultSymbol;
     if (isShorthandAmbientModuleSymbol(moduleSymbol)) {
       exportDefaultSymbol = moduleSymbol;
@@ -51930,7 +52123,7 @@ function createTypeChecker(host) {
     }
     const file = (_a = moduleSymbol.declarations) == null ? void 0 : _a.find(isSourceFile);
     const specifier = getModuleSpecifierForImportOrExport(node);
-    if (!specifier) {
+    if (!specifier || moduleSymbol.flags === 512 && ((_b = moduleSymbol.exports) == null ? void 0 : _b.has("default"))) {
       return exportDefaultSymbol;
     }
     const hasDefaultOnly = isOnlyImportableAsDefault(specifier);
@@ -52759,15 +52952,15 @@ function createTypeChecker(host) {
             moduleReference
           );
         }
-        if (moduleResolutionKind === 3 /* Node16 */ || moduleResolutionKind === 99 /* NodeNext */) {
+        if (false) {
           const isSyncImport = currentSourceFile.impliedNodeFormat === 1 /* CommonJS */ && !findAncestor(location, isImportCall) || !!findAncestor(location, isImportEqualsDeclaration);
           const overrideHost = findAncestor(location, (l) => isImportTypeNode(l) || isExportDeclaration(l) || isImportDeclaration(l));
-          if (isSyncImport && sourceFile.impliedNodeFormat === 99 /* ESNext */ && !hasResolutionModeOverride(overrideHost)) {
+          if (isSyncImport && sourceFile.impliedNodeFormat === 99 /* ESNext */ && !hasResolutionModeOverride2(overrideHost)) {
             if (findAncestor(location, isImportEqualsDeclaration)) {
               error2(errorNode, Diagnostics.Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead, moduleReference);
             } else {
               let diagnosticDetails;
-              const ext = tryGetExtensionFromPath2(currentSourceFile.fileName);
+              const ext = tryGetExtensionFromPath3(currentSourceFile.fileName);
               if (ext === ".ts" /* Ts */ || ext === ".js" /* Js */ || ext === ".tsx" /* Tsx */ || ext === ".jsx" /* Jsx */) {
                 const scope = currentSourceFile.packageJsonScope;
                 const targetExt = ext === ".ts" /* Ts */ ? ".mts" /* Mts */ : ext === ".js" /* Js */ ? ".mjs" /* Mjs */ : void 0;
@@ -52778,14 +52971,14 @@ function createTypeChecker(host) {
                       void 0,
                       Diagnostics.To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Colon_module_to_1,
                       targetExt,
-                      combinePaths(scope.packageDirectory, "package.json")
+                      combinePaths2(scope.packageDirectory, "package.json")
                     );
                   } else {
                     diagnosticDetails = chainDiagnosticMessages(
                       /*details*/
                       void 0,
                       Diagnostics.To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0,
-                      combinePaths(scope.packageDirectory, "package.json")
+                      combinePaths2(scope.packageDirectory, "package.json")
                     );
                   }
                 } else {
@@ -117311,10 +117504,7 @@ function getOutputExtension(fileName, options) {
   return fileExtensionIs(fileName, ".json" /* Json */) ? ".json" /* Json */ : options.jsx === 1 /* Preserve */ && fileExtensionIsOneOf(fileName, [".jsx" /* Jsx */, ".tsx" /* Tsx */]) ? ".jsx" /* Jsx */ : fileExtensionIsOneOf(fileName, [".mts" /* Mts */, ".mjs" /* Mjs */]) ? ".mjs" /* Mjs */ : fileExtensionIsOneOf(fileName, [".cts" /* Cts */, ".cjs" /* Cjs */]) ? ".cjs" /* Cjs */ : ".js" /* Js */;
 }
 function getOutputPathWithoutChangingExt(inputFileName, ignoreCase, outputDir, getCommonSourceDirectory2) {
-  return outputDir ? resolvePath(
-    outputDir,
-    getRelativePathFromDirectory(getCommonSourceDirectory2(), inputFileName, ignoreCase)
-  ) : inputFileName;
+  return outputDir ? `${outputDir}${directorySeparator}${inputFileName.slice(getCommonSourceDirectory2().length)}` : inputFileName;
 }
 function getOutputDeclarationFileName(inputFileName, configFile, ignoreCase, getCommonSourceDirectory2 = () => getCommonSourceDirectoryOfConfig(configFile, ignoreCase)) {
   return getOutputDeclarationFileNameWorker(inputFileName, configFile.options, ignoreCase, getCommonSourceDirectory2);
@@ -122419,6 +122609,7 @@ var ProgramUpdateLevel = /* @__PURE__ */ ((ProgramUpdateLevel2) => {
   ProgramUpdateLevel2[ProgramUpdateLevel2["Update"] = 0] = "Update";
   ProgramUpdateLevel2[ProgramUpdateLevel2["RootNamesAndUpdate"] = 1] = "RootNamesAndUpdate";
   ProgramUpdateLevel2[ProgramUpdateLevel2["Full"] = 2] = "Full";
+  ProgramUpdateLevel2[ProgramUpdateLevel2["Resolutions"] = 3] = "Resolutions";
   return ProgramUpdateLevel2;
 })(ProgramUpdateLevel || {});
 function updateSharedExtendedConfigFileWatcher(projectPath, options, extendedConfigFilesMap, createExtendedConfigFileWatch, toPath3) {
@@ -130293,6 +130484,11 @@ function createWatchProgram(host) {
   if (configFileName) {
     configFileWatcher = watchFile2(configFileName, scheduleProgramReload, 2e3 /* High */, watchOptions, WatchType.ConfigFile);
   }
+  let pnpFileWatcher;
+  const pnpApiPath = getPnpApiPath(__filename);
+  if (pnpApiPath) {
+    pnpFileWatcher = watchFile2(pnpApiPath, scheduleResolutionReload, 2e3 /* High */, watchOptions, WatchType.ConfigFile);
+  }
   const compilerHost = createCompilerHostFromProgramHost(host, () => compilerOptions, directoryStructureHost);
   setGetSourceFileAsHashVersioned(compilerHost);
   const getNewSourceFile = compilerHost.getSourceFile;
@@ -130355,6 +130551,10 @@ function createWatchProgram(host) {
       configFileWatcher.close();
       configFileWatcher = void 0;
     }
+    if (pnpFileWatcher) {
+      pnpFileWatcher.close();
+      pnpFileWatcher = void 0;
+    }
     extendedConfigCache == null ? void 0 : extendedConfigCache.clear();
     extendedConfigCache = void 0;
     if (sharedExtendedConfigFileWatchers) {
@@ -130390,7 +130590,7 @@ function createWatchProgram(host) {
   function getCurrentProgram() {
     return builderProgram && builderProgram.getProgramOrUndefined();
   }
-  function synchronizeProgram() {
+  function synchronizeProgram(forceAllFilesAsInvalidated = false) {
     writeLog(`Synchronizing program`);
     Debug.assert(compilerOptions);
     Debug.assert(rootFileNames);
@@ -130402,7 +130602,7 @@ function createWatchProgram(host) {
         resolutionCache.onChangesAffectModuleResolution();
       }
     }
-    const { hasInvalidatedResolutions, hasInvalidatedLibResolutions } = resolutionCache.createHasInvalidatedResolutions(customHasInvalidatedResolutions, customHasInvalidLibResolutions);
+    const { hasInvalidatedResolutions, hasInvalidatedLibResolutions } = resolutionCache.createHasInvalidatedResolutions(forceAllFilesAsInvalidated ? returnTrue : customHasInvalidatedResolutions, customHasInvalidLibResolutions);
     const {
       originalReadFile,
       originalFileExists,
@@ -130610,13 +130810,19 @@ function createWatchProgram(host) {
     updateLevel = 2 /* Full */;
     scheduleProgramUpdate();
   }
+  function scheduleResolutionReload() {
+    writeLog("Clearing resolutions");
+    resolutionCache.clear();
+    updateLevel = 3 /* Resolutions */;
+    scheduleProgramUpdate();
+  }
   function updateProgramWithWatchStatus() {
     timerToUpdateProgram = void 0;
     reportFileChangeDetectedOnCreateProgram = true;
     updateProgram();
   }
   function updateProgram() {
-    var _a, _b, _c, _d;
+    var _a, _b, _c, _d, _e;
     switch (updateLevel) {
       case 1 /* RootNamesAndUpdate */:
         (_a = perfLogger) == null ? void 0 : _a.logStartUpdateProgram("PartialConfigReload");
@@ -130626,12 +130832,19 @@ function createWatchProgram(host) {
         (_b = perfLogger) == null ? void 0 : _b.logStartUpdateProgram("FullConfigReload");
         reloadConfigFile();
         break;
+      case 3 /* Resolutions */:
+        (_c = perfLogger) == null ? void 0 : _c.logStartUpdateProgram("SynchronizeProgramWithResolutions");
+        synchronizeProgram(
+          /*forceAllFilesAsInvalidated*/
+          true
+        );
+        break;
       default:
-        (_c = perfLogger) == null ? void 0 : _c.logStartUpdateProgram("SynchronizeProgram");
+        (_d = perfLogger) == null ? void 0 : _d.logStartUpdateProgram("SynchronizeProgram");
         synchronizeProgram();
         break;
     }
-    (_d = perfLogger) == null ? void 0 : _d.logStopUpdateProgram("Done");
+    (_e = perfLogger) == null ? void 0 : _e.logStopUpdateProgram("Done");
     return getCurrentBuilderProgram();
   }
   function reloadFileNamesFromConfigFile() {
@@ -137426,7 +137639,14 @@ function createPackageJsonImportFilter(fromFile, preferences, host) {
     return false;
   }
   function getNodeModulesPackageNameFromFileName(importedFileName, moduleSpecifierResolutionHost) {
-    if (!importedFileName.includes("node_modules")) {
+    const pnpapi = getPnpApi(importedFileName);
+    if (pnpapi) {
+      const fromLocator = pnpapi.findPackageLocator(fromFile.fileName);
+      const toLocator = pnpapi.findPackageLocator(importedFileName);
+      if (!(fromLocator && toLocator)) {
+        return void 0;
+      }
+    } else if (!importedFileName.includes("node_modules")) {
       return void 0;
     }
     const specifier = ts_moduleSpecifiers_exports.getNodeModulesPackageName(
@@ -138003,6 +138223,9 @@ function isImportableFile(program, from, to, preferences, packageJsonFilter, mod
   return hasImportablePath;
 }
 function isImportablePath(fromPath, toPath3, getCanonicalFileName, globalCachePath) {
+  if (getPnpApi(fromPath)) {
+    return isImportablePathPnp(fromPath, toPath3);
+  }
   const toNodeModules = forEachAncestorDirectory(toPath3, (ancestor) => getBaseFileName(ancestor) === "node_modules" ? ancestor : void 0);
   const toNodeModulesParent = toNodeModules && getDirectoryPath(getCanonicalFileName(toNodeModules));
   return toNodeModulesParent === void 0 || startsWith(getCanonicalFileName(fromPath), toNodeModulesParent) || !!globalCachePath && startsWith(getCanonicalFileName(globalCachePath), toNodeModulesParent);
@@ -166278,7 +166501,34 @@ function getCompletionEntriesForNonRelativeModules(fragment, scriptPath, mode, p
           );
         }
       };
-      if (fragmentDirectory && getResolvePackageJsonExports(compilerOptions)) {
+      const checkExports = (packageFile, packageDirectory, fragmentSubpath) => {
+        const packageJson = readJson(packageFile, host);
+        const exports2 = packageJson.exports;
+        if (exports2) {
+          if (typeof exports2 !== "object" || exports2 === null) {
+            return true;
+          }
+          const keys = getOwnKeys(exports2);
+          const conditions = getConditions(compilerOptions, mode);
+          addCompletionEntriesFromPathsOrExports(
+            result,
+            /*isExports*/
+            true,
+            fragmentSubpath,
+            packageDirectory,
+            extensionOptions,
+            program,
+            host,
+            keys,
+            (key) => singleElementArray(getPatternFromFirstMatchingCondition(exports2[key], conditions)),
+            comparePatternKeys
+          );
+          return true;
+        }
+        return false;
+      };
+      const shouldCheckExports = fragmentDirectory && getResolvePackageJsonExports(compilerOptions);
+      if (shouldCheckExports) {
         const nodeModulesDirectoryLookup = ancestorLookup;
         ancestorLookup = (ancestor) => {
           const components = getPathComponents(fragment);
@@ -166297,35 +166547,53 @@ function getCompletionEntriesForNonRelativeModules(fragment, scriptPath, mode, p
           const packageDirectory = combinePaths(ancestor, "node_modules", packagePath);
           const packageFile = combinePaths(packageDirectory, "package.json");
           if (tryFileExists(host, packageFile)) {
-            const packageJson = readJson(packageFile, host);
-            const exports2 = packageJson.exports;
-            if (exports2) {
-              if (typeof exports2 !== "object" || exports2 === null) {
-                return;
+            const fragmentSubpath = components.join("/") + (components.length && hasTrailingDirectorySeparator(fragment) ? "/" : "");
+            if (checkExports(packageFile, packageDirectory, fragmentSubpath)) {
+              return;
+            }
+          }
+          return nodeModulesDirectoryLookup(ancestor);
+        };
+      }
+      const pnpApi = getPnpApi(scriptPath);
+      if (pnpApi) {
+        const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
+        const dependencyNameMatch = fragment.match(pathRegExp);
+        if (dependencyNameMatch) {
+          const [, dependencyName, subPath] = dependencyNameMatch;
+          let unqualified;
+          try {
+            unqualified = pnpApi.resolveToUnqualified(dependencyName, scriptPath, { considerBuiltins: false });
+          } catch {
+          }
+          if (unqualified) {
+            const packageDirectory = normalizePath(unqualified);
+            let shouldGetCompletions = true;
+            if (shouldCheckExports) {
+              const packageFile = combinePaths(packageDirectory, "package.json");
+              if (tryFileExists(host, packageFile) && checkExports(packageFile, packageDirectory, subPath)) {
+                shouldGetCompletions = false;
               }
-              const keys = getOwnKeys(exports2);
-              const fragmentSubpath = components.join("/") + (components.length && hasTrailingDirectorySeparator(fragment) ? "/" : "");
-              const conditions = getConditions(compilerOptions, mode);
-              addCompletionEntriesFromPathsOrExports(
-                result,
-                /*isExports*/
-                true,
-                fragmentSubpath,
+            }
+            if (shouldGetCompletions) {
+              getCompletionEntriesForDirectoryFragment(
+                subPath,
                 packageDirectory,
                 extensionOptions,
                 program,
                 host,
-                keys,
-                (key) => singleElementArray(getPatternFromFirstMatchingCondition(exports2[key], conditions)),
-                comparePatternKeys
+                /*moduleSpecifierIsRelative*/
+                false,
+                /*exclude*/
+                void 0,
+                result
               );
-              return;
             }
           }
-          return nodeModulesDirectoryLookup(ancestor);
-        };
+        }
+      } else {
+        forEachAncestorDirectory(scriptPath, ancestorLookup);
       }
-      forEachAncestorDirectory(scriptPath, ancestorLookup);
     }
   }
   return arrayFrom(result.values());
@@ -166459,9 +166727,15 @@ function getCompletionEntriesFromTypings(host, program, scriptPath, fragmentDire
   for (const root of typeRoots) {
     getCompletionEntriesFromDirectories(root);
   }
-  for (const packageJson of findPackageJsons(scriptPath, host)) {
-    const typesDir = combinePaths(getDirectoryPath(packageJson), "node_modules/@types");
-    getCompletionEntriesFromDirectories(typesDir);
+  if (getPnpApi(scriptPath)) {
+    for (const root of getPnpTypeRoots(scriptPath)) {
+      getCompletionEntriesFromDirectories(root);
+    }
+  } else {
+    for (const packageJson of findPackageJsons(scriptPath, host)) {
+      const typesDir = combinePaths(getDirectoryPath(packageJson), "node_modules/@types");
+      getCompletionEntriesFromDirectories(typesDir);
+    }
   }
   return result;
   function getCompletionEntriesFromDirectories(directory) {
@@ -183554,6 +183828,29 @@ var ConfiguredProject2 = class extends Project3 {
     return this.projectReferences;
   }
   updateReferences(refs) {
+    if (typeof process.versions.pnp !== `undefined`) {
+      const basePath = this.getCurrentDirectory();
+      const getPnpPath = (path) => {
+        try {
+          const pnpApi = getPnpApi(`${path}/`);
+          if (!pnpApi) {
+            return path;
+          }
+          const targetLocator = pnpApi.findPackageLocator(`${path}/`);
+          const { packageLocation } = pnpApi.getPackageInformation(targetLocator);
+          const request = combinePaths(targetLocator.name, getRelativePathFromDirectory(
+            packageLocation,
+            path,
+            /*ignoreCase*/
+            false
+          ));
+          return pnpApi.resolveToUnqualified(request, `${basePath}/`);
+        } catch {
+          return path;
+        }
+      };
+      refs = refs == null ? void 0 : refs.map((r) => ({ ...r, path: getPnpPath(r.path) }));
+    }
     this.projectReferences = refs;
     this.potentialProjectReferences = void 0;
   }
@@ -184268,6 +184565,7 @@ var _ProjectService = class _ProjectService {
       log,
       getDetailWatchInfo
     );
+    this.pnpWatcher = this.watchPnpFile();
     (_a = opts.incrementalVerifier) == null ? void 0 : _a.call(opts, this);
   }
   toPath(fileName) {
@@ -186149,7 +186447,7 @@ Dynamic files must always be opened with service's current directory or service
     this.performanceEventHandler = performanceEventHandler;
   }
   setHostConfiguration(args) {
-    var _a;
+    var _a, _b;
     if (args.file) {
       const info = this.getScriptInfoForNormalizedPath(toNormalizedPath(args.file));
       if (info) {
@@ -186198,6 +186496,8 @@ Dynamic files must always be opened with service's current directory or service
         this.hostConfiguration.watchOptions = substitution;
         this.hostConfiguration.beforeSubstitution = substitution === watchOptions ? void 0 : watchOptions;
         this.logger.info(`Host watch options changed to ${JSON.stringify(this.hostConfiguration.watchOptions)}, it will be take effect for next watches.`);
+        (_b = this.pnpWatcher) == null ? void 0 : _b.close();
+        this.watchPnpFile();
       }
     }
   }
@@ -187196,6 +187496,29 @@ Dynamic files must always be opened with service's current directory or service
     });
   }
   /** @internal */
+  watchPnpFile() {
+    const pnpApiPath = getPnpApiPath(__filename);
+    if (!pnpApiPath) {
+      return;
+    }
+    return this.watchFactory.watchFile(
+      pnpApiPath,
+      () => {
+        this.forEachProject((project) => {
+          for (const info of project.getScriptInfos()) {
+            project.resolutionCache.invalidateResolutionOfFile(info.path);
+          }
+          project.markAsDirty();
+          updateProjectIfDirty(project);
+        });
+        this.delayEnsureProjectForOpenFiles();
+      },
+      250 /* Low */,
+      this.hostConfiguration.watchOptions,
+      WatchType.ConfigFile
+    );
+  }
+  /** @internal */
   watchPackageJsonFile(file, path, project) {
     Debug.assert(project !== void 0);
     let result = (this.packageJsonFilesMap ?? (this.packageJsonFilesMap = /* @__PURE__ */ new Map())).get(path);
